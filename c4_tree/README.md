# 树的定义

树是**一些节点的集合**。集合可以是空集，若非空，则树由一个根节点 r 和 0 或多个非空的子树组成。（子树非空）

每颗子树的根都被来自根 r 的一条有向边连接。因此一棵树是 Ｎ 个节点和 N-1 条边的集合。

对任意节点，其**深度**是从根到其路径的长，其**高**是从其到一个叶子结点最长路径的长。

一棵树的所有节点的深度的和称为其内部路径长。

### 树的遍历方法

- 先序：对节点的处理在其所有子节点之前进行。因此第一个被处理的是根。
- 后序：与先序相反，先处理子节点。因此其左或右的第一个叶子节点是首先处理的。
- 中序：针对二叉树，先处理子节点，然后是本节点，最后是右节点。特点是输出有序。

# 二叉树

因为二叉树最简单，本章 3/4 的篇幅都围绕它展开。

### 表达式树

表达式树是二叉树的一种应用。对于形如 `A^B` 这样的，由左右两个操作数(operand)和中间一个操作符(operator)组成的结构，就可以存储为一个三节点的表达式树。

可见表达式树的叶子节点都是操作数，而非叶子节点都是操作符。

当然一般表达式也允许单目或多目运算的情形，此时对树做相应适配即可。这里的问题是简化过的。

对表达式树进行中序遍历的打印，输出的就是对人友好的表达式格式，如

    (1 + 1) / (2 + 2)

### 二叉查找树

这里 **查找** 被实现的方式是进行 **排序**。因此二叉查找树的性质是：对于树中的每个节点，其左子树的所有节点的值都比他小，所有右子树的节点的值都比他大。

值得一提的是查找树节点的删除。叶子节点可以直接删除。删除非叶子节点时，如果只有一棵子树，直接将子树上提是肯定满足约束的。有问题的情形是：当节点有两个子树的时候，上提一个子树后，另一棵子树如何安置的问题。遍历其并进行重新插入操作是一个方法，但不是好方法。递归删除是另一种方法：选择左或右子树删除其根节点，同时将此根节点上提。这样总能递归到前面的两种情形。可惜仍然不是好方法。

从递归方法出发，我们发现其实可以不选择子树的根节点进行挪移（递归挪移的中间节点都是无意义的）。而是尽可能往下找，直接找到叶子节点最好了。而目标节点需要满足的条件只是：比左子树的所有剩余节点大，且比右子树的所有剩余节点小。显然左子树的最大节点和右子树的最小节点都满足这个条件，且它们都是叶子节点。

### AVL 树

AVL 是人名的缩写。定义是：

    带有平衡条件的二叉查找树

其平衡条件是：

    任意节点的左右子树高度最大相差 1

维护这种平衡条件的操作叫做 **旋转**。它的功能是返回一棵新的子树，并满足平衡条件。

设不平衡节点的左右高度分别是 H 和 H+2，其中高的那颗称为高子树。容易想到，我们只需要反转高子树与根的边的方向，使高子树成为新的根，原根+低子树+高子树的一个子树（我们称为过继子树）组成为高子树的**新子树**。似乎就能使高子树的高度 -1，低子树的高度 + 1。新树得到平衡。

可能有问题的地方是：高子树过继的子树到底是高的那颗还是低的那颗，因为容易看到，这颗过继子树的高度其实没有发生变化。考虑原根与高子树的大小对比是确定的，那么原根的新位置也是确定的，“过继子树是高子树的哪一侧子树”也是确定的（一定是原根那一侧）。

当过继的是低子树时，原高子树的高度成功 -1，达到 H+1，新子树高度 +1，达到 H+1，过继子树高度不变，范围是[0, H+1]。此时树是平衡的。而且新树的左右子树高度是相等的。

当过继的子树与未过继的子树高度相等时，基本和上一场景一样，只有过继子树的高度会变成 H+2，此时新树仍是平衡的，但新子树侧的高度更高。

而当过继的是高子树时，原高子树的高度范围会变成[0, H]，新子树的高度会是 H+2。新树仍不平衡。



把二叉树转换为二维表！再写一个转平衡树的方法！行代表父子，列代表左右，且x列的任意值都比x+1的任意值小。

