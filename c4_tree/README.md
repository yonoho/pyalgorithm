# 树的定义

树是**一些节点的集合**。集合可以是空集，若非空，则树由一个根节点 r 和 0 或多个非空的子树组成。（子树非空）

每颗子树的根都被来自根 r 的一条有向边连接。因此一棵树是 Ｎ 个节点和 N-1 条边的集合。

对任意节点，其**深度**是从根到其路径的长，其**高**是从其到一个叶子结点最长路径的长。

一棵树的所有节点的深度的和称为其内部路径长。

### 树的遍历方法

- 先序：对节点的处理在其所有子节点之前进行。因此第一个被处理的是根。
- 后序：与先序相反，先处理子节点。因此其左或右的第一个叶子节点是首先处理的。
- 中序：针对二叉树，先处理子节点，然后是本节点，最后是右节点。特点是输出有序。

# 二叉树

因为二叉树最简单，本章 3/4 的篇幅都围绕它展开。

### 表达式树

表达式树是二叉树的一种应用。对于形如 `A^B` 这样的，由左右两个操作数(operand)和中间一个操作符(operator)组成的结构，就可以存储为一个三节点的表达式树。

可见表达式树的叶子节点都是操作数，而非叶子节点都是操作符。

当然一般表达式也允许单目或多目运算的情形，此时对树做相应适配即可。这里的问题是简化过的。

对表达式树进行中序遍历的打印，输出的就是对人友好的表达式格式，如

    (1 + 1) / (2 + 2)

### 二叉查找树

这里 **查找** 被实现的方式是进行 **排序**。因此二叉查找树的性质是：对于树中的每个节点，其左子树的所有节点的值都比他小，所有右子树的节点的值都比他大。

值得一提的是查找树节点的删除。叶子节点可以直接删除。删除非叶子节点时，如果只有一棵子树，直接将子树上提是肯定满足约束的。有问题的情形是：当节点有两个子树的时候，上提一个子树后，另一棵子树如何安置的问题。遍历其并进行重新插入操作是一个方法，但不是好方法。递归删除是另一种方法：选择左或右子树删除其根节点，同时将此根节点上提。这样总能递归到前面的两种情形。可惜仍然不是好方法。

从递归方法出发，我们发现其实可以不选择子树的根节点进行挪移（递归挪移的中间节点都是无意义的）。而是尽可能往下找，直接找到叶子节点最好了。而目标节点需要满足的条件只是：比左子树的所有剩余节点大，且比右子树的所有剩余节点小。显然左子树的最大节点和右子树的最小节点都满足这个条件，且它们都是叶子节点。

### AVL 树

AVL 是人名的缩写。定义是：

    带有平衡条件的二叉查找树

AVL树单旋转生效的条件是+2节点旋转后能上升，这需要+1节点的新子节点（0节点）不能与+2节点同侧。即从0节点到+2节点的路径，其两条边需要是同向的。

把二叉树转换为二维表！再写一个转平衡树的方法！行代表父子，列代表左右，且x列的任意值都比x+1的任意值小。

