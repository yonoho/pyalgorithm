为了方便，本文描述的排序算法都基于以下假设：

- 排序对象为整数数组
- 排序对象都可以放入内存，排序过程也没有内存限制

排序就是让数组产生 “序” 的过程。后面会证明：任何基于比较的算法都需要至少 `N*Log(N)` 次比较。因此算法效率的主要关注点就是比较次数，尽量不要做重复的比较。空间效率相对不那么关心，因为这些算法都可以写成直接交换式而不产生显著的额外内存消耗。

# 分析

### 排序的一般下界

决策树（decision tree）是证明这个下界的抽象概念。决策树的节点代表所有可能的决策，边代表某条已知条件。某个节点所有已知的条件包含从该节点到根的全部边。叶子节点只包含一种决策，即在所有已知条件下，作出的最终决策。

在排序算法里，决策树的节点代表**在已知条件下数组可能的排列**，两条边代表两个元素比较的结果（因此这里的决策树是二叉树）。叶子结点代表一种固定的排序。举例含有两个元素的决策树：根节点是 `[a, b] / [b, a]`，其左边是 `a < b`，左子节点就是 `[a, b]`，右边是 ` a > b`，右子节点是 `[b, a]`。

存在以下定理：

- 具有 L 个叶子节点的决策树深度至少是 Log(L)。
- 因为具有 N 个元素的决策树必然有 N! 个叶子节点，它的决策树深度至少是 Log(N!)。
- Log(N!) = Ω(N*Log(N))。证明略。

# 算法

### 插入排序

插入排序是最简单直观的排序方式，我们从前向后遍历元素，确保该元素位置之前的切片是排过序的。具体方法为向前比较，如果逆序则交换元素。

显然它的复杂度是 O(N^2)，且这个极限在完全逆序输入时是可以达到的。这个算法慢的地方在于它只比较和交换相邻的元素，即把一个新元素插入已排序数组的过程是 O(N) 的。

这个复杂度对任意只通过交换相邻元素来进行排序的算法都适用。证明过程需要定义一个概念为 **逆序**(inversion)，指的是任意两个位置不符合排序要求的元素。注意 [3, 2, 1] 这样的数组逆序数为 3。只交换相邻元素的算法每次只能消除一个逆序。存在以下定理：

- N 个互异数的数组，平均逆序数是 N(N-1)/4。考虑数组排列可证明。

### 希尔排序(Shell sort)

Shell 的名字来源于它的发明者 Donald Shell，跟壳无关。


