不相交集是用来解决 “等价问题” 的数据结构。

# 定义

### 等价关系

对于集合 S 中的每一对元素 (a, b)，如果 aRb 都有布尔类型的值，那么称在集合 S 上定义了**关系(relation) **R。且如果 aRb == True，则 a 与 b 有关系。

**等价关系（equivalence relation）**是满足以下 3 个性质的关系 R：

1. 自反性：对于所有 a∈S，aRa。
2. 对称性：aRb 当且仅当 bRa。
3. 传递性：若 aRb 且 bRc，则 aRc。

典型的等价关系如：电气连通性。

### 动态等价性问题

对于一个等价关系 “～”，典型的问题是确定两个元素是否具有这个关系，以及如何操作一个集合里的所有关系。基本的处理思路可以是存储一个二维关系表并进行查询和更新，但考虑到等价关系的 3 个性质，会发现这本质上是个动态问题。二维表的方式维护了大量冗余数据，且更新时依然要处理等价关系的特性。

**等价类（equivalence class）** 定义为 S 的一个子集，它包含所有与 a 等价的元素。可见集合 S 正好能够划分为若干个等价类，每个元素都正好出现在某一个等价类中，等价类互不相交。因此判断元素等价问题可以转换为判断它们是否位于同一个等价类内。

对于初始的集合 S，没有任何等价关系的情况，其等价类数量等于其元素数。增加等价关系的操作等于合并等价类。查找等价类的操作可以定义为 `class_nane Find(element)`，它返回等价类的一种标识，标识相等的就认为属于同一个等价类。为了简化暂不考虑分割操作，分割等于从等价类中移除某些元素并创建新的等价类。

合并算法是动态的，因为操作过程中集合会发生变化。那么 find 操作就必须保持一定的一致性，要么通过在线（on-line）模式执行，即该操作执行时一定要给出结果才能继续；要么通过离线（off-line）模式执行，此模式下算法可以先通览所有的 find 和 union 操作，然后按自由顺序给出 find 的结果，但需保证该结果对在此 find 之前执行的 union 操作均有效。

在设计算法时有以下需要注意的点：

1. 一个大小为 N 的集合，最多可以有 N-1 次 union 操作，我们对算法的评估总要考虑这种终极情况。
2. 我们不关心元素的值，我们只关心他们的位置。因此可以使用一个整数数组代替元素，通过某种简单的散列算法将元素值转为其下标。
3. 我们甚至不关心等价类的具体名字，只需要在对等价元素执行 find 时，返回的值相等即可。哪怕在一次 union 前后同一元素 find 的名字不同也没关系。

在数据结构方面，可以设计一种 O(1) find 或 O(1) union 的算法，但两者似乎无法同时达到。下面介绍的算法在任意 M 次 find 和 N-1 次 union 的运行时间将只比 O(M+N) 多一点。

### 基本数据结构

这里我们使用树来存储等价类，因为树上的结点都有相同的根（类名）。因为 find 操作仅需要向上查找父节点，每个元素需要存储的值只有父节点的下标，我们可以使用一个整数数组来存储这棵树。union 操作即将 a 集合的根的父节点指向 b，或反过来。find 操作的复杂度只取决于树的深度，因此我们期望让树矮一点，即集合 S 完全等价时的树，理想深度为 1。

### union 技巧

理想深度的树如果要实现必然依赖平衡操作，这会增加 union 的耗时，我们先考虑一些常数时间的方案：

当两颗树合并时，我们可以选择更深的树成为新根，因为这样不会导致新树深度增加（仅在两树深度相同时 +1），这种方法叫做 **按深度求并（union-by-height）**。此时树的深度不会超过 Log(N)。

这里还有一个空间优化的小技巧。考虑到我们实际是使用一个数组存储父节点下标的，同时根节点的父节点是空。一般我们会考虑把根节点的父节点存储为 null 或 0（下标不从 0 开始的情况下）。而按深度求并的算法又需要每个根节点存储其树深度。我们其实可以利用起根节点为空的空间，用来存储其深度。为了和父节点下标区分，可以将其转为负值。

除按深度求并外还有一种方法是**按大小求并（union-by-size）**，它们的效率区别很小。

### 路径压缩

路径压缩就是上面提到的平衡操作，但它不是在 union 中进行的，而是 find。因为我们的理想目标是深度 1，因此我们的操作便是：在执行 find 时，将查找路径上的每一个节点都挂载到根下。

路径压缩与按大小求并是兼容的，但与按高度求并存在冲突，因为它会改变树的高度。本质上也没办法去更新树的高度，因为我们只存了父节点的下标，无从（也未必经济）计算新的树高。这时可以不去计算，继续使用之前的树高，虽然它不准确。这个值可以称为**秩（rank）**，是对树高的一种估计。

当同时使用按秩合并和路径压缩时，算法在最坏情形下“几乎”是线性的，即 `θ(M*α(M,N))` （设 M 大于等于 N），其中 α(M,N) 是连续执行 N=LogM(N) 直到 N ≤ 1 时的次数。它增长得比 LogN 还慢很多，接近线性，但不是线性。因证明太麻烦了，此处略。
