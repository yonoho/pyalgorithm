# 定义

一个**图（graph）**G 由**顶点（Vertex）**集 V 和**边（Edge）**集 E 组成。每条边即一对点 (v, w)。如果点对是有序的，那么图就是有向的（directed），也称为**有向图（digraph）**。顶点 v, w **邻接（adjacent）** 当且仅当 (v, w) ∈ E。有时边还带有一个额外值，称为**权（weight）**或**值（cost）**。

图中的一条路径是一个顶点序列，其中任意连续的两个顶点都构成一条边。路径的长度等于其含有的边的数量，对于只有一个顶点的特殊情况，可以将其看成 0 长路径。如果路径 (v, v) 是一条边，这个路径也被叫做 loop，我们一般不讨论这种情况。**简单路径**指路径中的顶点全部互异的路径（首尾除外）。

有向图中的圈 cycle 是满足首尾顶点相同且长度至少为 1 的路径，如果路径是简单路径，那么这个 cycle 就是简单 cycle。对于无向图，我们要求边是互异的，因为无向图中的 (v, w, v) 其实只包含一条边。如果一个图没有 cycle，那么称其为 acyclic，其中的有向图也称为 DAG。

    这里没有翻译 loop 和 cycle 是因为汉字的环和圈的意思区分度不足。考虑到后面不会讨论有 loop 的情况，我们简单把 cycle 称为 “环”。wikipedia 也是这样翻译的。

如果无向图中每个顶点到其他顶点都有一条路径，那么称该无向图为**连通的（connected）**。如果一个有向图也具有这种性质，则称其为**强连通的（strongly onnected）**。如果一个有向图不是强连通的，但其无向版本（基础图，undelying graph）是连通的，那么称该有向图为**弱连通的（weakly connected）**。**完全图（complete graph）**是任意两个顶点间都存在一条路径的图。

表示图的数据结构可以是一个二维数组，但对于比较稀疏的图，这样很浪费空间。因此更常用的是邻接表（adjacency list），对每个顶点，保存一个链表存储其连通的所有顶点。

拓扑排序（topological sort）是对“有向无环图”的顶点的一种排序，它的排序规则是如果存在一条路径使得 v 在 w 的前面，那么在拓扑排序中 v 就要在 w 的前面。显然这种排序不是唯一的，且对于有环的图也是无法排序的。生成拓扑排序的方法通常是先找到一个入度（indgree，指向该顶点的边的数量）为 0 的顶点，然后扫描。

# 最短路径算法

赋权路径长是一条路径的权重和；无权路径长是一条路径上的边数。单源最短路径问题是：给定一个赋权图 G = （V，E）和一个顶点 s 作为输入，找出从 s 到 G 中剩余全部顶点的最短赋权路径。为什么要找出所有其他顶点，因为还不存在找出从 s 到一个顶点比找出从 s 到所有顶点更快（一个常数因子以上）的算法。

边的权重可以是负值，这时最短路径可能是不确定的，因为可能存在一个负权重环（negative-cost cycle），导致每经过一次该环都能让总路径长变小。

### 无权最短路径

在选定 s 后，首先 s 到 s 的距离为 0，到所有邻接顶点的距离为 0 + 1，再次从每个邻接顶点出发到下一级邻接顶点的距离为 0 + 1 + 1。。。递归这个过程就能遍历出全部结果。这个方法叫做广度优先搜索（breadth-first search），因为我们从 0 出发逐级递增路径长，因此第一次算出的路径长总是最短的。

在程序中，每个顶点需要记录三个值：Known、d、p，分别为该顶点是否已知（被扫描过）、s 到该顶点的距离 和 该顶点的前序顶点。p 可以用来回溯整条路径。

### Dijkstra 算法

Dijkstra 算法用来解决赋权图的问题，但基本思路与广度优先算法差不多，核心都是在确认已知最短路径的基础上，递进计算。区别在于确认已知最短路径的方法：已知 dv 是最短路径长，那么当 E（v，w） 是 v 起始的最短路径边时， dw 的最短路径为 dv + c(v, w)。

这个算法属于贪婪算法的一例，贪婪算法通常会分阶段求解一个问题，每个阶段它都只选择最优解解决一部分问题，如果问题有残留则进入下一个阶段。这类算法的问题在于它不总是正确的，因为全局的最优解也许并不会在每个阶段都是最优解。但 Dijkstra 算法在本例中是正确的，只要没有负权重的话，因为此时总路径长的累积是单调递增的。

算法里保存的中间数据与广度优先搜索相同。初始化时只有 s 点的值为 (True, 0, 0)，第一阶段标记 known v 的所有下一连通节点的 d、p 值，然后选择 非 known 中 dv 最小的一个 v 标记其 Known 值为 True。然后选定该新顶点 v 并进入下一阶段。在第一阶段中，如果连通节点的 Known 值为 True 则跳过不做处理，如果 d 值不为空且小于当前计算的新 d 值，则不更新。

本算法的主要时间消耗在于查表，因为有一步是选择 d 值最小的顶点标记为 Known。如果图是稠密的（E数=V数的平方），直接扫描邻接表的复杂度是 O（V**2），即 O（E），基本最优；如果图是稀疏的（E数=V数），查找过程便需要优先队列来实现。如果选择优先队列，又要考虑 dv 的值有可能在过程中更新的问题。可以选择 DecreaseKey 操作，也可以选择重复插入，而在 DeleteMin 时做去重处理，但这有可能导致队列过大，进而减慢速度。

### 负边权重问题

当存在负边权重时，Dijkstra 算法确认最短路径（标记 Known）的行为就不可靠了。另外试图通过为所有边的权重 `+ max(abs(weights))` 的方法也是行不通的，因为这会使边更多的路径增加的总权重更多。其实能保持最短路径不变的，修改权重的方法是乘以某个系数，但这不解决负数的问题。

解决的关键在于抛弃 Known 字段的定义，因为它已经不再可靠了，而之前它是递归过程的一个终止条件。当考虑到一些极端情况时会发现：从 s 到 v 的每一条路径，在全部算完权重前都是不可抛弃的，因为你难说最后一段不会出现一个负值改变历史。因此穷举每一条可能的路径并在最后进行比较是可能的解决方法，且时间消耗并不高，约为 O(E + V)，但它的空间消耗太大了。我们把思路转换一下，不保存全量的历史路径，而是选择在每次 d(v) 发生变化时重算 v 所有的连通顶点 w 的 d(w) 值，这样会造成很多的重复计算（O（E * V）），但不需要额外的存储空间。并且考虑到负边权重在现实中是个小概率事件，这个算法的实际时间消耗也不会过分得坏。

### 无环图


