# 定义

一个**图（graph）**G 由**顶点（Vertex）**集 V 和**边（Edge）**集 E 组成。每条边即一对点 (v, w)。如果点对是有序的，那么图就是有向的（directed），也称为**有向图（digraph）**。顶点 v, w **邻接（adjacent）** 当且仅当 (v, w) ∈ E。有时边还带有一个额外值，称为**权（weight）**或**值（cost）**。

图中的一条路径是一个顶点序列，其中任意连续的两个顶点都构成一条边。路径的长度等于其含有的边的数量，对于只有一个顶点的特殊情况，可以将其看成 0 长路径。如果路径 (v, v) 是一条边，这个路径也被叫做 loop，我们一般不讨论这种情况。**简单路径**指路径中的顶点全部互异的路径（首尾除外）。

有向图中的圈 cycle 是满足首尾顶点相同且长度至少为 1 的路径，如果路径是简单路径，那么这个 cycle 就是简单 cycle。对于无向图，我们要求边是互异的，因为无向图中的 (v, w, v) 其实只包含一条边。如果一个图没有 cycle，那么称其为 acyclic，其中的有向图也称为 DAG。

    这里没有翻译 loop 和 cycle 是因为汉字的环和圈的意思区分度不足。考虑到后面不会讨论有 loop 的情况，我们简单把 cycle 称为 “环”。wikipedia 也是这样翻译的。

如果无向图中每个顶点到其他顶点都有一条路径，那么称该无向图为**连通的（connected）**。如果一个有向图也具有这种性质，则称其为**强连通的（strongly onnected）**。如果一个有向图不是强连通的，但其无向版本（基础图，undelying graph）是连通的，那么称该有向图为**弱连通的（weakly connected）**。**完全图（complete graph）**是任意两个顶点间都存在一条路径的图。

表示图的数据结构可以是一个二维数组，但对于比较稀疏的图，这样很浪费空间。因此更常用的是邻接表（adjacency list），对每个顶点，保存一个链表存储其连通的所有顶点。

拓扑排序（topological sort）是对“有向无环图”的顶点的一种排序，它的排序规则是如果存在一条路径使得 v 在 w 的前面，那么在拓扑排序中 v 就要在 w 的前面。显然这种排序不是唯一的，且对于有环的图也是无法排序的。生成拓扑排序的方法通常是先找到一个入度（indgree，指向该顶点的边的数量）为 0 的顶点，然后扫描。

# 最短路径算法

赋权路径长是一条路径的权重和；无权路径长是一条路径上的边数。单源最短路径问题是：给定一个赋权图 G = （V，E）和一个顶点 s 作为输入，找出从 s 到 G 中剩余全部顶点的最短赋权路径。为什么要找出所有其他顶点，因为还不存在找出从 s 到一个顶点比找出从 s 到所有顶点更快（一个常数因子以上）的算法。

边的权重可以是负值，这时最短路径可能是不确定的，因为可能存在一个负权重环（negative-cost cycle），导致每经过一次该环都能让总路径长变小。

### 无权最短路径

在选定 s 后，首先 s 到 s 的距离为 0，到所有邻接顶点的距离为 0 + 1，再次从每个邻接顶点出发到下一级邻接顶点的距离为 0 + 1 + 1。。。递归这个过程就能遍历出全部结果。这个方法叫做广度优先搜索（breadth-first search），因为我们从 0 出发逐级递增路径长，因此第一次算出的路径长总是最短的。

在程序中，每个顶点需要记录三个值：Known、d、p，分别为该顶点是否已知（被扫描过）、s 到该顶点的距离 和 该顶点的前序顶点。p 可以用来回溯整条路径。

### Dijkstra 算法

Dijkstra 算法用来解决赋权图的问题，但基本思路与广度优先算法差不多，核心都是在确认已知最短路径的基础上，递进计算。区别在于确认已知最短路径的方法：已知 dv 是最短路径长，那么当 E（v，w） 是 v 起始的最短路径边时， dw 的最短路径为 dv + c(v, w)。

这个算法属于贪婪算法的一例，贪婪算法通常会分阶段求解一个问题，每个阶段它都只选择最优解解决一部分问题，如果问题有残留则进入下一个阶段。这类算法的问题在于它不总是正确的，因为全局的最优解也许并不会在每个阶段都是最优解。但 Dijkstra 算法在本例中是正确的，只要没有负权重的话，因为此时总路径长的累积是单调递增的。

算法里保存的中间数据与广度优先搜索相同。初始化时只有 s 点的值为 (True, 0, 0)，第一阶段标记 known v 的所有下一连通节点的 d、p 值，然后选择 非 known 中 dv 最小的一个 v 标记其 Known 值为 True。然后选定该新顶点 v 并进入下一阶段。在第一阶段中，如果连通节点的 Known 值为 True 则跳过不做处理，如果 d 值不为空且小于当前计算的新 d 值，则不更新。

本算法的主要时间消耗在于查表，因为有一步是选择 d 值最小的顶点标记为 Known。如果图是稠密的（E数=V数的平方），直接扫描邻接表的复杂度是 O（V**2），即 O（E），基本最优；如果图是稀疏的（E数=V数），查找过程便需要优先队列来实现。如果选择优先队列，又要考虑 dv 的值有可能在过程中更新的问题。可以选择 DecreaseKey 操作，也可以选择重复插入，而在 DeleteMin 时做去重处理，但这有可能导致队列过大，进而减慢速度。

### 负边权重问题

当存在负边权重时，Dijkstra 算法确认最短路径（标记 Known）的行为就不可靠了。另外试图通过为所有边的权重 `+ max(abs(weights))` 的方法也是行不通的，因为这会使边更多的路径增加的总权重更多。其实能保持最短路径不变的，修改权重的方法是乘以某个系数，但这不解决负数的问题。

解决的关键在于抛弃 Known 字段的定义，因为它已经不再可靠了，而之前它是递归过程的一个终止条件。当考虑到一些极端情况时会发现：从 s 到 v 的每一条路径，在全部算完权重前都是不可抛弃的，因为你难说最后一段不会出现一个负值改变历史。因此穷举每一条可能的路径并在最后进行比较是可能的解决方法，且时间消耗并不高，约为 O(E + V)，但它的空间消耗太大了。我们把思路转换一下，不保存全量的历史路径，而是选择在每次 d(v) 发生变化时重算 v 所有的连通顶点 w 的 d(w) 值，这样会造成很多的重复计算（O（E * V）），但不需要额外的存储空间。并且考虑到负边权重在现实中是个小概率事件，这个算法的实际时间消耗也不会过分得坏。

### 无环图

假设已知图是无环的，那么针对 Dijkstra 算法的查找过程就存在一项改进：以拓扑排序的顺序来标记 Known 属性，可以免除使用优先队列的麻烦，因为此时不存在 Unknown 的输入顶点。

# 网络流问题

设边的权重代表容量，那么有一个问题是两个顶点之间的最大流量及其路径是什么。一个简单的算法是构造一个**残余图（residual graph）**，残余图初始化为流量图，然后我们找出一条路径，并将其权重从残余图中减去。重复这个过程直到找不到路径。所有被减去的路径的组合就是最大流量图。为了效率，搜索路径时应该在每一步尽可能选择最大流量的边。

# 最小生成树（minimum spanning tree）

无向图的最小生成树是由该图的全部顶点和部分边组成的树，且总权重最低。显然它必须是连通的。现实中的应用场景为：用最少的电线连接一间屋子里所有的插座。有向图的最小生成树也有意义，但这里不讨论。因为树的边数固定为顶点数 - 1，因此最小生成树只对有权图有意义。

对于任一生成树 T，如果将一条不属于 T 的边 e 添加进来，则产生一个圈。如果从该圈中去除任意一条边，则又恢复生成树的特性。如果去除的边的权重比 e 低，则新的生成树的总权重就比之前低。这个思路可以用于实现生成树的最小属性。

### Prim 算法

本算法的思路与 Dijkstra 类似，每个循环我们都选择一个已在生成树上的顶点 u，然后找到一条边 （u, v），满足 v 不在树上，且边权重最小。然后把 v 添加到树上，并重复这个过程。如何选取第一个顶点？随便选就行，因为图是无向的，顶点的顺序不会影响最终的结果。

选择过程保存的数据与上面类似，我们为每个顶点保存 3 个值（known，dv，pv），known 代表是否已在树上；dv 代表连接 v 和树上任意顶点的最小权重；pv 代表 dv 生效的那个 known 顶点。dv 的更新方法为：对于新增的 known v，遍历其连接的 unknown w，其 w，dw = min（dw， c（v，w））。在 unknown 顶点集中选择下一个顶点的方法，不用堆的运行时间是 O（V**2），对于稠密的图是最优解；用二叉堆的运行时间是O（E*log（V）），对于稀疏图表现更好。

### Kruskal 算法

第二种贪婪策略是连续地按照最小的权重选择边，如果这条边不会造成环就使用，否则跳过。这样当最终所有顶点连通时算法结束。

这里对连通的判断要用到上一章的**不相交集**概念。初始状态下所有顶点均不相交，判断一条边要不要用的方法是看该边的两个顶点是否等价，当决定使用一条边时，需要对两个顶点执行合并操作。即不相交集的 Union/Find 算法。这个过程也是在处理一个森林（树的集合），我们把不同的树合并，直到只剩下一棵树，就是最小生成树。

# 深度优先搜索的应用

深度优先搜索中会为每个顶点保存一个 bool 类型的值，表示是否已被访问过。

### 无向图

无向图是连通的，当且仅当从任一节点开始的深度优先搜索能访问到每一个节点。

**深度优先生成树（depth-first spanning tree）**是按深度优先搜索生成的树，特殊之处在于存在虚线（背向边（back edge）），当搜索过程中遇到一条边 (v, w) 的两个顶点都是已访问节点，但 （v，w）却不是生成树的边时，我们就将 (v, w) 记为背向边。即这条边在生成树中是不需要的（但在图中是存在的）。可以看到生成树的边与背向边的合集等于图的边。

### 双连通性

如果一个连通的无向图中的**任一**顶点删除之后，剩下的图仍然连通，则称该图为双连通的（biconnected）。即每个顶点都在深度优先生成树中拥有至少有一条背向边。

对于非双连通图，那些删除之后图便不再连通的顶点称为**割点（articulation point）**。

可以通过深度优先搜索以线性时间找出连通图中所有的割点。具体做法为：首先从任一顶点开始执行深度优先搜索，并按访问顺序给顶点编号，此序号记为 num(v)；然后为深度优先生成树的每个节点计算 low(v)，其值为：从 v 出发，经过 0 至若干条边，再加上 0 或 1 条背向边，能够到达的节点的 num(v) 的最小值。一个高效的计算 low 的方法是对生成树执行后序遍历，因为某节点可达的 low 值对其父节点全部可达。且由定义可知，low(v) 是对 v 来说以下值中的最小者：

- num(v)
- 所有背向边(v, w)中的最小 num(w)，即与 v 相连的背向边的全部对端顶点的最小 num
- 树的所有边(v, w)中的最小 low(w)，即后序遍历的返回值，如果我们定义其返回最小 low 值的话

low 值的含义是什么？首先 low(v) 一定不大于 num(v)，排除相等的情况，当 low(v) < num(v) 时，它一定是通过最后的背向边到达的，那么在 v 与 ～num(low(v)) 代表的节点之间，必然至少存在一条生成树路径 + 一条背向边路径。那么这两个顶点之间的生成树路径上的点，就全部不是割点。限制只含有一条背向边是为了让约束成立。

剩下的是根据以上信息找出所有割点。根是割点当且仅当它有多于一个的子节点，因为如果它有两个子节点，那么删除根时，两个子树将不连通，两个图也不会连通。因为生成树会在根处分叉的原因在于：其左子树的任何一点都无法，在不通过根的前提下，与右子树上的任何一点连通，否则右子树上的点就会出现在左子树中。这个找割点的方法在非根节点不成立，因为此时左子树和右子树之间可能通过当前节点和当前节点的祖先节点与右侧实现双连通。那么我们怎么判断非根节点是其左子树和右子树间唯一的中间节点呢？答案就是，如果非根节点 v 有任一个子节点 w，满足 low(w) >= num(v)，那么 从 w 出发到 v 的邻接节点都必然通过 v，因此 v 是割点。然后证明其必要性：通过上面 low 值的含义我们可得，v 的全部子节点的 low 值都小于 num(v) 时，v 一定不是割点。因此算法是结论的必要条件。

### 欧拉回路

欧拉回路就是“一笔画”问题，且可能附加“起点和终点相同”的额外条件。这个问题在 1736 年被欧拉解决，因此称为欧拉回路，且图论从此诞生。如果不带附加条件，即起点和终点允许不同的话，该问题叫做欧拉环游。

问题的解法是：把图形表示为无向图，然后统计每个顶点的度。如果有一个奇数度的顶点，那么必然无解，因为最终会停在这一点。如果有两个奇数度的顶点，那么也许可以实现环游。如果没有奇数度的顶点，那么也许可以实现回路。其实这个条件不只是必要的，也是充分的。

在满足以上必要条件的前提下，找欧拉回路的一个直观方法是深度优先搜索。但可能遇到的问题是提前绕回，即一旦把起点近距离的回路绕完，则远处的边便无法再访问。因此我们的搜索算法应该 “尽可能地绕远”。可以想到一种方法是：当深度优先搜索过程结束时，便检查路径上是否还有未访问的边。然后把该未访问的边走一遍，并将新路径加回主路径上。问题是加进来的这条路径是什么样的，如果是环，那么很好处理。有可能不是环吗？

因为图是连通的，且每个顶点的度都是偶数，所以首先我们可以确定新路径一定能回到主路径。然后，回来的交点有没有可能无法保持一致呢？答案也是不可能，因为假如回来的交点与起点不同，且无法再次离开，那么起点与终点的度数一定是奇数。

综上，我们总结出一个找欧拉回路的方法，并意识到：顶点度全部是偶数的图，等价于若干个相交的环。

在无向图中寻找一个简单圈，该圈通过所有顶点。这个问题叫做汉密尔顿圈问题。这个问题没有简单解。

### 有向图

利用深度优先搜索同样可以以线性时间遍历有向图。如果图不是强连通的，那么从某些节点出发的搜索可能永远无法到达某些顶点。比如在有向无环图的拓扑排序中的下游顶点永远也到达不了自己的上游顶点。即使在有环图中也是一样，某些顶点到另一些顶点之间只有 “单行道”。

那么我们其实可以从任意节点开始深度优先搜索，并建立一个生成森林。像无向图一样，我们建立的森林中也会存在一些虚线（非树边），他们包括：背向边，这是环的未被使用的另一部分；还有一些**前向边（forward edge）**，他们是一些冗余边；最后还有一些交叉边，他们负责把不同的生成树连接起来。

深度优先搜索的一个用途是判断图是否有环。一个有向图没有环当且仅当它的生成树没有背向边。

可见深度优先生成树实现了对图顶点的一种排序，通过这些父子关系我们可以给边按方向分类：是前向还是背向。

### 查找强分支

对于非强连通图，可能存在强连通的分支。我们可以通过两次深度优先搜索来得到它们。也即意味着此方法可以用于测试有向图的强连通性。

具体的算法是先在图 G 上执行一次深度优先操作，并遍历生成森林，对每棵生成树按照**后序遍历**给 G 的顶点编号，即第一棵树的叶子节点最先得到序号，最后一棵树的根节点最后得到序号。然后将 G 的所有边方向反转得到 Gr，并按顶点编号的倒序在 Gr 上执行深度优先搜索，从而得到另一个深度优先森林。此时，在新深度优先森林中的每棵树都构成一个强连通分支。

当 v 和 w 处在 G 的同一个强分支中时，G 必然存在 从 v 到 w 和 从 w 到 v 的路径。因此在 Gr 也必然存在这样的路径。因此如果 v 和 w 不在 Gr 的同一棵生成树中，那么它们一定也不在 G 的同一个强分支中。必要性证毕。

对充分性的证明等价于证明：如果 v 和 w 在 Gr 的同一棵生成树中，则必然存在 从 v 到 w 的路径和从 w 到 v 的路径（不论是在 Gr 还是 G 中）；等价于证明：如果 v 和 w 所在树的根是 r，则必然存在 v 到 r 的双向路径和 w 到 r 的双向路径。

因为 v 是 x 的后裔，因此在 Gr 中肯定存在一条从 x 到 v 的路径，因此在 G 中肯定存在一条从 v 到 x 的路径。此外因为 x 是根节点，那么 x 的序号肯定比 v 高，因此要么 x 在后面的树上，要么 x 是 v 的祖先节点。又因为 G 中肯定存在 从 v 到 x 的路径，那么排除 x 和 v 在不同树上的情况。因此 G 中肯定存在从 x 到 v 的路径。

# NP-完全性

### 难与易

虽然复杂度有很多级，但有一些关键分水岭，比如多项式时间。即以 N 为底，任意常数为指数的多项式时间。比多项式高的是指数时间，即 a^N 这种。通常认为多项式时间是 “有限时间内可解” 的上限。

同时计算机还有一些 “不可能” 解决的问题，这类问题被称作 “不可判定（undecidable）” 问题。一个典型的例子是停机问题：判断一个程序能否在有限时间内结束，还是会无限执行。假设存在一种方法判断程序 P 能否停机，那么就可以写出一个新程序
    
    def loop(f) :
        if halting(f):
            run_forever()
        else:
            return

问题出在调用 loop(loop) 的时候会发生什么，如果 halting(loop) 为真，那么 loop 会进入 run_forever 进而不会停机；如果 halting(loop) 为假，那么 loop 又会直接结束。这个例子就像 “这是一句假话” 一样总是会导致矛盾。

因为在涉及自身引用时容易出现不可判定问题，这一类也被叫做 “递归不可判定（recursively undecidable）”。

### NP 类

NP(nondeterministic polynomial-time) 类问题比不可判定问题简单一点。确定型机器执行的指令是确定的，每一条指令之后都唯一确定下一条指令的内容。但非确定型机器在一条指令结束时有一组指令可以选择执行，且当其中存在一条指令导向正确结果的话，机器总是会选择这一条指令。即非确定型机器有很好的猜测能力。（神经网络似乎符合这个定义，但我没看到网上有人这样说）非确定型机器是一项重大改进，但也并不能解决所有问题，比如不可判定问题。

判断 NP 分类的一个简单方法是用 是/否 问题方法描述该问题。如果在多项式时间内我们能够证明任意 “是” 的实例是正确的，那么这就是一个 NP 问题。“否” 的场景无需关心，因为机器总是会选择 “是” 的分支。（P 类是确定型机器能在多项式时间可解的问题类）汉密尔顿圈问题是 NP 类问题，因为给定一个圈，很容易验证其正确性。

所有确定型机器多项式时间可解的问题都属于 NP，因为这个解就算一种检验。注意 NP 的定义是 P 的超集，因此最简单的问题也包含在内。那么除了多项式时间可解的问题，NP 中是否还有确定型机器多项式时间不可解的问题呢？毕竟检验一个解比找出一个解要容易得多。目前反例还没有被找到，这个问题也叫做 P=NP 问题。如果 P=NP，那么非确定型机器比起确定型机器就不算一个特别大的改进。（因为它并不能解决更多问题）

### NP-完全 问题

NP-Complete 问题是 NP 中最难的那一类，它们的特性是：NP 中的任何一个问题都可以在多项式时间内归约（reduced）成 NP-完全 问题。比如以十进制输入一个数，转换成二进制进行计算，再转换成十进制返回，我们就说把十进制计算规约成了二进制计算。这么做的意义在于：如果任一 NP-完全问题有多项式时间解，那么所有 NP 问题都有多项式时间解。也就是上面 P=NP 问题的一个充分解。

证明 NP 集合的一个问题 P 是 NP-完全问题的方法是找到另一个 NP-完全问题 P1，并证明 P1 可多项式规约成 P。这个证明方法存在一个问题是第一个 NP-完全问题从哪来，第一个被证明是 NP-完全问题的是**可满足性问题（satisfiability problem）**，这个问题是给定一个布尔表达式，问是否存在一套变量值使得该表达式的值为 True。当存在时，该表达式为可满足的，不存在时是不可满足的。即当不可满足时，表达式的值恒为 False。可满足性问题显然符合 NP 的定义，同时 Cook 证明了它是 NP-完全的。计算机的一个形式化模型称作图灵机（Turing machine），Cook 指出了存在一种多项式布尔表达式，可以模拟图灵机的所有操作，尽管它非常的长且复杂。
